Attribute VB_Name = "modMain"
'GoProgram State added to StartTimeIsSet
Option Explicit

'Public Const cbDefault = &H8000000F
Public Const cbEnabled = vbYellow
Public Const cbDisabled = &H8000000F

Private Declare Function SafeUDTGetDim Lib "oleaut32" Alias "SafeArrayGetDim" (pArray As Any) As Long
Private Declare Function SafeArrayGetDim Lib "oleaut32" (pArray() As Any) As Long

Public Declare Function ShellExecute _
                            Lib "SHELL32.DLL" _
                            Alias "ShellExecuteA" ( _
                            ByVal hwnd As Long, _
                            ByVal lpOperation As String, _
                            ByVal lpFile As String, _
                            ByVal lpParameters As String, _
                            ByVal lpDirectory As String, _
                            ByVal nShowCmd As Long) _
                            As Long

'Public Declare Function Beep Lib "kernel32" (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long
Private Declare Function GetComputerNameA Lib "KERNEL32" (ByVal lpBuffer As String, nSize As Long) As Long

Public cbOrange As Long
Private PreciseClock As clsTimer

Public Type defLink
    Type As String  'UpLink or DownLink (Replaces using UpLink & DownLink)
    Flag As Long    'The Link Flag that is associated
    Raise As Boolean    'True = Raise Linked Flag, False=Lower Linked Flag
End Type

Public Type defFlag  'Properties where to display the Image (Blank if not displayed)
    pos As Long         'Flag(idx) = 0 if not Up (Both Row & Col > 0)
    Row As Long         'Row on which to display the flag,  Set on UP, Clear after down
    Col As Long         'Col on which to display the flag
    FixedRow As Long 'Position is preset on load, so do not clear on event
    FixedCol As Long
    Queue As Boolean    'Queue any Flag Event (Sounds, Controllers), do not clear on event
    Changed As Boolean  'Used to generate Controller Event  'Clear after event handled
End Type

Private Type defGroupDefault  'Are applied to the above when Signal Is Loaded (by LoadProfile)
    group As String     'Group to which these defaults are applied
    FixedRow As Long
    FixedCol As Long
    Queue As Boolean
End Type

Private Type defController
    Name As String
    IpAddress As String
    On As String
    Off As String
    state As Boolean    'True = should be on
    Connection As String
    Sound As String
End Type

'Public Type defGroup    'Only defined for Fixed Groups (Sound, Lights)
'    GroupName As String
'    Queue As Boolean    'Process signals sequentially
'End Type

Private Type defSignalAttribute 'Initialled loaded from .ini file [Signal] section
'These are defined again as they are used once the timer is
'running - they are loaded from the UpDown
'These are the same for OFF and ON
    Type As String  'Class, Finish, Sound, Recall
    Name As String  'Name of the Signal  Class Flag 1
    Image As Picture    'GIF image
    Flag As defFlag   'Flag Attributes
    group As String  'Flag is positioned below any UP Flag in this Group
    Class As Long    '-1 = none Classes(Csidx) to speed access in DoTimerEvents
    TTL As Long     'Time this flag is displayed in Millisecs
                    'It will be off for the same Period (if more than 1 cycle)
    CyclesRequired As Long  'No of On cycles by timer before creating OFF event
    OnCycles As Long    'Count of on cycles, completed after next off(when timer is enabled)
    TTD As Long         'Time Off
    ImageFilePath As String 'Flag Image
                            'timer must be unique
    Links() As defLink   'Used when signal is Raised(UP) & when Lowered(Down)
    Controller As Long  'This is the controller used when the flag is visible
                        '-1 = no linked controller
    Silent As Boolean   'Set by DoTimerEvents if Sound Signals are not generated by the link
                        'Must be unset by DoTimerEvents as well
End Type

Private Type defSignalEvt
'    Class As Long
    Signal As Long
    Raise As String         'Up, Down or ""     'Cannot be defined as Boolean
    Silent As String        'True, False or ""  'as we wanny tell if it wants leaving or changing
End Type

Private Type defButtonEvt
'    Class As Long
    Button As Long
    Enabled As String       'True, False or "" (dont change)
End Type

Private Type defFunctionCallEvt
    Index As Long
    Name As String
End Type

Private Type defEvt
    ElapsedTime As Long
    Class As Long
    Signal As Long
    Message As String
    Signals() As defSignalEvt
    Buttons() As defButtonEvt
    FunctionCalls() As defFunctionCallEvt
    Focus As Long           'Idx of Command button to give focus to (0)=none
                            'Note BackColor wants cnaging to Green if it was Default
End Type

Private Type defClass       'These are extracted when the Events are loaded
    Name As String          'Same as Signal and Command Caption
    Signal As Long          'Idx of Class Signal
    ClassStartElapsedTime As Long   'ClassSeparation * CsIdx (without multiplier)
    Warning As Long         'First Signal when Class Flag is raised
    start As Long           'Time when Class cannot be postponed
                            'Time when Class can be recalled
    Offset As Long          'Offset to all class times due to Postponement
                            'or Recall
End Type

Private Type defStart
    Previous As Long    'Previous Class Started (even if Recalled or Postponed after recall)
                    'Will be same as Next if General Recalled
    Next As Long    'Next Class to start
    Last As Long    'Last Class to Start (will change if txtNoOfStarts is changed by user)
End Type

Private Type defKey
    KeyName As String   'F1,F6
    Code As Long        '116,119
    state As Long  '0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
    Cancel As Boolean   'If True next press will Lower the flag
'None,GoRaisePostpone,GoLowerPostpone,GoRaiseRecall,GoLowerRecall
'GoRaiseGeneralRecall,GoLowerGeneralRecall,GoRaiseFinish
    FunctionCall As String
End Type

Public Type defState    'Public so we can save it, General Recall changed to Postpone
    Program As Long     '0=No Profile,1=Loading Profile,2=Profile Loaded
                        '3=Start Time Set,4=Start Sequence Running,5=Start Sequence Finished
    Sequence As Long    '0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
    Recalls As Long     '0=None,1=Both,2=Recall,3=General Recall
    StartClass As defStart   'NextClass, PreviousClass
    EventPause As Long  '-1=indefinite, 0 = not paused, 60 = for 60 secs
    NextEventTime As Long   'The current timer event we are processing
                            'Incremented when we have processed the Events
'    FunctionClass As Long   'Used for Postpone & Recalls else 0
    GrStartTime As Long   'IOnly to display Time since General Recall Start
End Type

Private Type defFunctionKey
    KeyNo As Long
End Type

Public CurrentProfile As String     'The Current Sequence selected
Public Loading As Boolean   'Suppress Queueing Commands, and Flag Position errors

Public StaticCommands() As Boolean  'CommandButtons defined in the initially loaded form
                                    'True = dont reposition
Public Controllers() As defController
Public SignalAttributes() As defSignalAttribute
Public Evts() As defEvt
Public Classes() As defClass
Public Keys() As defKey     'Keys(0)=Unused, Keys(1)=F5, Keys(2)=F8
Public state As defState
Public aProgramState(0 To 5) As String
Public StateToKeyIdx(0 To 4) As Long
Public aSequenceState(0 To 4) As String
Public aRecallsState(0 To 3) As String
Public aKeyState(0 To 4) As String
Public RecallSignalIdx As Long   'The Flag index used for recalls
                                'Must be defined as a signal (normally 10)

'Public ElapsedTime As Long  'Seconds before or after start time
Public RowCount As Long
Public ColCount As Long
Public ColCountFree As Long 'ColCount less any Fixed Cols
Public SignalImageFilePath As String
Public SequencesFilePath As String
'This is the same as in Inno
'XP = C:\Documemts and Settings\All Users\Application Data\
'Win10 C:\ProgramData\
Public CommonAppData As String

'These MUST be separate because Eidx is in scope when LoadRecall is called
'Dim Eidx As Long    'Evts(Eidx) index   base = 0, -1 = not open
'Sidx has separate args passed when loading
'Must set Sidx to -1 when Signal= is seen in an Event section
'And hang on to it until a new Signal= is seen
Private Sidx As Long

'These are the variables that are set up in the [Profile] section
Private RecallControl As Boolean    'Not used
Private ButtonControl As Boolean    'Not used
Private ButtonEvents As Boolean     'Enable Events Button (make visible)
Private ClassSilenceControl As Boolean 'Silence Class Flags raised at same time as a Class Flag is Lowered
Public SoundOnAllFinishers As Boolean   'SYC Default is False
Public SkipClassOnRecall As Boolean     'SYC Default is False
Public Multiplier As Long               'Speed up events for testing
Public ClassSeparation As Long      'Seconds between class starts

'Required by by Load Profile & ParseProfile
Private GroupDefaults() As defGroupDefault
Private RecallTemplate() As String
Private ClassTemplate() As String
Private EventClassName As String    'The Class the Events created relate to
'Private ClassStartElapsedTime As Long  #Now defined separately in classes(cidx)
Public ResultsFileName As String
Public ResultsFileCh As Long

Public BatteryVoltage As Single
Public SyncEventsToNoOfStarts As Boolean   'True = Requires Synchronising
Public NoOfStarts As Long

Sub Main()
Dim i As Long

    On Error GoTo Main_Error
    If App.PrevInstance Then
        MsgBox "RacingSignals is already running" & vbCrLf & "You cannot have it running twice on the same PC", vbCritical, "Racing Signals"
        GoTo Main_Exit
    End If
    LogFileCh = -1  'force open for output
    
    Call WriteLog("Environment Settings")
    i = 1
    Do
        Call WriteLog(Environ(i))
        i = i + 1
    Loop Until Environ(i) = ""
    
'There is no environment variable to get the ALL USERS\Application Data location
'internationally Application data is re-named si the english must NOT be used

    CommonAppData = GetSpecialFolderA(CSIDL_COMMON_APPDATA)
    Call WriteLog("GetSpecialFolder CSIDL_COMMON_APPDATA = " & CommonAppData)
    Call WriteLog("Windows Version = " & GetVersion1())
    Call WriteLog("User Default LocaleID = " & GetUserDefaultLCID())
    Call WriteLog("Decimal Separator = " & GetDecimalSeparator)

    Call WriteLog("User has Administrator Rights = " & CBool(IsNTAdmin(ByVal 0&, ByVal 0&)))

    Call WriteLog("***************")
    
    
    WriteLog App.EXEName & ".exe " & App.Major & "." & App.Minor & "." & App.Revision & " Started"
    If Is64bit Then
        WriteLog "Version = " & GetVersion1() & " (64 bit)"
    Else
        WriteLog "Version = " & GetVersion1() & " (32 bit)"
    End If

    WriteLog "Install log = " & Environ("USERPROFILE") & "\Local Settings\Temp\Setup Log [install date] #[sequence no].txt"
'    Action.Load (Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\Sequences\" & "ScarboroughMultiple.csv")
    'SignalImageFilePath = Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\SignalImages\"
    SignalImageFilePath = CommonAppData & "Arundale\RacingSignals\SignalImages\"
    WriteLog "SignalImageFilePath = " & SignalImageFilePath
    'SequencesFilePath = Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\Sequences\"
    SequencesFilePath = CommonAppData & "Arundale\RacingSignals\Sequences\"
    WriteLog "SequencesFilePath = " & SequencesFilePath
    
    
    cbOrange = RGB(255, 102, 0) '    RGB(255, 153, 0)
    Multiplier = 1
    ClassSeparation = 0
    RecallControl = True
    ButtonControl = True
    ClassSilenceControl = True
    aProgramState(0) = "0=No Profile"
    aProgramState(1) = "1=Loading Profile"
    aProgramState(2) = "2=Profile Loaded"
    aProgramState(3) = "3=Start Time Set"
    aProgramState(4) = "4=Start Sequence Running"
    aProgramState(5) = "5=Start Sequence Finished"
    aSequenceState(0) = "0=Disabled"
    aSequenceState(1) = "1=Not Started"
    aSequenceState(2) = "2=Postpone"
    aSequenceState(3) = "3=Recalls"
    aSequenceState(4) = "4=Finish"
    aRecallsState(0) = "0=None"
    aRecallsState(1) = "1=Both"
    aRecallsState(2) = "2=Recall"
    aRecallsState(3) = "3=General Recall"
    aKeyState(0) = "0=Disabled"
    aKeyState(1) = "1=Postpone"
    aKeyState(2) = "2=Recall"
    aKeyState(3) = "3=General Recall"
    aKeyState(4) = "4=Finish"
    
    Set PreciseClock = New clsTimer
    
    WriteLog "Loading frmMain"
    
    Load frmMain

'We can use the ClubBurgee to control who it is licenced to
   frmMain.ClubBurgee.Picture = LoadPicture(SignalImageFilePath & "ClubBurgee.gif")
'We cant place an image control in front of a picture control without making
'the putting the image in the picture container
'    Set frmMain.Settings.Container = frmMain.Picture1
'    frmMain.Settings.Top = 0
'    frmMain.Settings.Left = 0
'You cannot setfocus while the form is loading
'This prevents the cboProfile being displayed in Blue
'    frmMain.txtFirstStartTime.SetFocus
    WriteLog "Loading frmDaventech"
    Load frmDaventech
    If frmMain.cboProfile.ListCount = 0 Then
        Unload frmMain  'exit program
    Else
        frmMain.Show
    End If
    
    WriteLog "frmMain.DisplayProgram"
    Call frmMain.DisplayProgram
    WriteLog "frmMain.DisplaySequence"
    Call frmMain.DisplaySequence
    WriteLog "frmMain.DisplayRecalls"
    Call frmMain.DisplayRecalls
'remove functionkeys    Call frmMain.DisplayKeys
    WriteState "Main"
'    Call SetProgramState(1)
Main_Exit:
Exit Sub

Main_Error:
    Select Case Err.Number
    Case Else
        MsgBox "Error " & Err.Number & " - " & Err.Description, vbCritical, "Main_Error"
    End Select
    Resume Next 'Only in sub Main (otherwise application does not terminate)
'    Resume Main_Exit
    
End Sub
'False if it fails

Public Function TimerOutput(OutputTime As Date) As Boolean
'Debug.Print Format$(OutputTime, "hh:mm:ss")
    TimerOutput = True
End Function

'Converts a Nul string to "0"
Public Function NulToZero(TxtIn As String) As String
    If TxtIn = "" Then
        NulToZero = "0"
    Else
        NulToZero = TxtIn
    End If
End Function

Public Function LoadProfile()
Dim DecryptedFileName As String
Dim EncryptedFileName As String
Dim ch As Long

Dim Section As String   'Signal=nnn
Dim Idx As Long   'Signal is the only section requiring an index (at the moment)
Dim Eidx As Long    'Evts(Eidx) index   base = 0, -1 = not open
Dim Lidx As Long    'SignalAttributes(Idx).Links(Lidx).Index
Dim Cidx As Long    'Controller() index
Dim Csidx As Long   'Classes(index) index=0 if no class starting
Dim Fcidx As Long   'Event index for FunctionCalls

Dim Template As String
Dim ElapsedTime As Long

Dim i As Long
Dim j As Long
Dim Secs As Long
Dim nextline As String
Dim CleanLine As String
Dim LineType As String
Dim CleanSection As String
Dim arry() As String    'Name=Values (Multiple Values Comma separated)
Dim arry1() As String   'Values in arry(1)
Dim MySignalTimer As Timer
Dim MyFont As New StdFont
Dim MyPicture As New StdPicture
Dim MyFrame As Frame
Dim MyLink As defLink
Dim SectionError As Boolean

Debug.Print "==============="

WriteLog "LoadProfile " & CurrentProfile

    On Error GoTo LoadProfile_err
'Check of profile has been selected
    If CurrentProfile = "" Then
        Exit Function
    End If
'    Call SetState("Program", 1)
    Loading = True
'Clear existing profile
    Unload frmEvents
'Set up Controller(0) for the Horn, even if nothing connected
    ReDim Controllers(0)
    ReDim SignalAttributes(1 To 1)  'this will clear the array
    Erase Evts
    ReDim GroupDefaults(0)
    ReDim RecallTemplate(0)
    ReDim ClassTemplate(0)
    ReDim Classes(0)    'CsIdx
'Set these up in the Profile
    ReDim Keys(3)   'Change to 0
    Keys(1).Code = 116
    Keys(1).KeyName = "F5"
    Keys(2).Code = 119
    Keys(2).KeyName = "F8"
    Keys(3).Code = 123
    Keys(3).KeyName = "F12"
    StateToKeyIdx(0) = 0    'No of Function keys in use
    StateToKeyIdx(1) = 1
    StateToKeyIdx(2) = 1
    StateToKeyIdx(3) = 2
    StateToKeyIdx(4) = 1
'Must be done after classes cleared because when starttime is cleared
'the start times in classes (if any) are displayed
    Call frmMain.ClearProfile
    
    Eidx = -1
    SoundOnAllFinishers = False 'If not defined as true in .ini
    SkipClassOnRecall = False 'If not defined as true in .ini
'    Sidx = -1
'    Bidx = -1
'Set up Controller(0) for the Horn, even if nothing connected
'Min of 1 controller
'    Call frmMain.ResetProfile
'    Call frmMain.ResetSignalTimers
'    Call frmMain.ResetCommands
'    Call frmMain.ResetFlags
'    Call frmMain.ResetFinish
'    Call frmMain.ResetRecall
    Call frmDaventech.OpenAndSend("")
'    Call frmMain.ResetEvents no longer required
'Set up new profile
'    frmMain.Caption = App.EXEName & " [" & App.Major & "." & App.Minor & "." _
'    & App.Revision & "] " & frmMain.cboProfile.List(frmMain.cboProfile.ListIndex)
    
'Change name to ClubBurgee    'requires putting in profile
'MsgBox SignalImageFilePath
'   frmMain.ClubBurgee.Picture = LoadPicture(SignalImageFilePath & "SycBurgee.gif")

    
    EncryptedFileName = SequencesFilePath & frmMain.cboProfile.List(frmMain.cboProfile.ListIndex) & ".ini"
WriteLog "File to be decrypted is  " & EncryptedFileName
    DecryptedFileName = Replace(EncryptedFileName, ".ini", ".tmp")
    Call DecryptFile(EncryptedFileName, DecryptedFileName)
WriteLog "Processing decrypted file"     'Don't give user a clue that a temp file has been created
 
 ch = FreeFile
    Open DecryptedFileName For Input As #ch
    Do Until EOF(ch)
        Line Input #ch, nextline
WriteLog nextline
        CleanLine = nextline
        LineType = CleanProfileLine(CleanLine)   'NextLine is cleaned, Returns "Open","Close","Update","Skip"
        If LineType = "Skip" Then   'no closing ] for this section
            GoTo Skip_line
        End If
 Debug.Print CleanLine  'Comments and whitespace removed
        arry = Split(CleanLine, "=")
'If we're reading in a template, then we do not action Open of Close
'at this time (we do it when LoadRecallEvent is processsd)
        If Section = "Template" And arry(0) <> "/Template" Then
                LineType = "Update"
            Else
'Stop
        End If
        Select Case LineType
'OPEN a new section
        Case Is = "Open"
            Section = arry(0)
            Select Case Section
            Case Is = "Profile"
            Case Is = "Class"   'create a new class
                If ClassSeparation > 0 Then GoTo Skip_line     'Ignore Class sections
'Arry(1) is passed to maintain compatibilty if Flag is say 707
                Csidx = NewClass(arry(1))
'                Csidx = Csidx + 1
'                state.StartClass.Last = Csidx
'                NoOfStarts = Csidx   'Max allowed
'                frmMain.txtNoOfStarts = NoOfStarts
'                If Csidx > UBound(Classes) Then
'                    ReDim Preserve Classes(Csidx)
'                End If
'                Idx = SignalFromClass(Csidx)
'                If Idx > 0 Then
'                    Classes(Csidx).Signal = Idx
'                    Classes(Csidx).Name = SignalAttributes(Idx).Name
'                    Classes(Csidx).ClassStartElapsedTime = (Csidx - 1) * ClassSeparation
'                    EventClassName = Classes(Csidx).Name
'                Else
'MsgBox "Class No in [Event=" & arry(1) & "] is not defined in Signal Flag", vbCritical, "LoadProfile"
'                End If
            Case Is = "Template"
                Template = arry(1)
                Select Case Template
                Case Is = "Recall"
                    RecallTemplate(0) = "'Recall Template"
                Case Is = "Class"   'create the class template
                    ClassTemplate(0) = "'ClassTemplate"
                Case Else
MsgBox "Template array " & arry(1) & " doesnt exist", vbCritical, "Parse Profile"
                
                End Select
            Case Is = "Event"
                If Eidx = -1 Then
                    Eidx = EventOpen(CLng(arry(1)) / Multiplier)
                Else
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    GoTo Skip_line
                End If
            Case Is = "Controller"
'Arry1 contains the Controller index
                If IsNumeric(arry(1)) Then
                    Cidx = arry(1)
                    If Cidx > UBound(Controllers) Then
                        ReDim Preserve Controllers(Cidx)
                    End If
                End If
                Controllers(Cidx).Name = "Controller (" & Cidx & ")"
            Case Is = "Signal"
                Lidx = 0
                If IsNumeric(arry(1)) Then
                    Idx = arry(1)
'Create the Signal Attributes array index
                    If Idx > UBound(SignalAttributes) Then
                        i = UBound(SignalAttributes)
                        ReDim Preserve SignalAttributes(1 To Idx)
                    Else
'Idx(1) is always created
                        If Idx > 1 Then
'Signals must be created in ascending order
MsgBox "Duplicated Signal(" & Idx & ") detected", vbCritical, "LoadProfile"
                            Section = ""
                            GoTo Skip_line   'Get next line
                        End If
                    End If
'Load a null picture so that we can test if image =0
'if no picture has been loaded
'                    Set SignalAttributes(Idx).Image = LoadPicture("")
'Default is None
                    SignalAttributes(Idx).Controller = -1
'                    SignalAttributes(Idx).Class = -1
'Create a timer for each Signal (even if we dont use it)
                    Load frmMain.SignalTimer(Idx)
'Create the Command(idx) if it doesn't exist
'and CommandsExists
                    If Not CommandExists(Idx) Then
                        Load frmMain.Commands(Idx)
                        If UBound(StaticCommands) < Idx Then
                            ReDim Preserve StaticCommands(Idx)
                            'created - false so dont reposition
                        End If
                        frmMain.Commands(Idx).Visible = True
'Loads it disabled (not sure why)
                        frmMain.Commands(Idx).Enabled = True
                    End If
'Create the Image Control if it doesnt exist
                Else
                    MsgBox "Section " & Section & " has no Index", vbCritical, "LoadProfile"
                    Section = ""
                End If
            Case Else
                MsgBox "Section " & Section & " not Defined", vbCritical, "LoadProfile"
                Section = ""
            End Select
'CLOSE this section
        Case Is = "Close"
            If Section = "" Then
MsgBox "Section " & CleanSection & " not open", vbExclamation, "LoadProfile"
                GoTo Skip_line
            End If
            Select Case Section
            Case Is = "Profile"
            Case Is = "Class"   'Close Section Class
            If ClassSeparation > 0 Then GoTo Skip_line     'Ignore Class sections
'Create the events for current class using the class template
'Must be done when Class is closed because StartElapsedTime will differ for each Class
                Call LoadClassEvents(Classes(Csidx).ClassStartElapsedTime / Multiplier)
            Case Is = "Template"
                Template = ""
            Case Is = "Controller"
'Stop
                Cidx = 0    'End of this Controller Default
            Case Is = "Signal"
'We have to so this at the end of the section because if CommandVisible has been changed
'we do not want to position it
                If StaticCommands(Idx) = False Then
                    Call frmMain.PositionCommand(Idx)
                End If
'Set command button caption to same as flag
                frmMain.Commands(Idx).Caption = SignalAttributes(Idx).Name
                Idx = 0       'End of this signal
            Case Is = "Event"
                Eidx = EventClose(Eidx)
'Must close the signal index as well
                Sidx = -1
            Case Else
            End Select
            Section = ""
            Idx = 0
            CleanSection = ""
'UPDATE an open section
        Case Is = "Update"
            If Section = "" Then
MsgBox "Line Outside section" & vbCrLf & nextline & vbCrLf, vbExclamation, "LoadProfile"
            GoTo Skip_line       'We should have a section defined
            End If
            ReDim arry1(0)
            If UBound(arry) > 0 Then
                arry1 = Split(arry(1), ",")
            End If
            Select Case Section
            Case Is = "Profile"
                Select Case arry(0)
                Case Is = "Name"
 'Now use the file name thas is displayed in the Combo box
 '                           frmMain.Caption = App.EXEName & " [" & App.Major & "." & App.Minor & "." _
 '                           & App.Revision & "] " & arry(1)
                Case Is = "Version"
 'This is the version of the .ini file
                Case Is = "GroupDefault"
                    For i = 1 To UBound(GroupDefaults)
                        If GroupDefaults(i).group = arry1(0) Then
                            Exit For
                        End If
                    Next i
                    If i > UBound(GroupDefaults) Then
                        ReDim Preserve GroupDefaults(i)
                    End If
                    GroupDefaults(i).group = arry1(0)
                    For j = 1 To UBound(arry1)
                        Select Case arry1(j)
                        Case Is = "LastCol"
                            GroupDefaults(i).FixedCol = ColCount
                            ColCountFree = ColCount - 1
                        Case Is = "LastCol-1"
                            GroupDefaults(i).FixedCol = ColCount - 1
                            ColCountFree = ColCount - 2
                        Case Is = "Row1"
                            GroupDefaults(i).FixedRow = 1
                        Case Is = "Row2"
                            GroupDefaults(i).FixedRow = 2
                        Case Is = "Row3"
                            GroupDefaults(i).FixedRow = 3
                        Case Is = "Row4"
                            GroupDefaults(i).FixedRow = 4
                        Case Is = "Queue"
                            GroupDefaults(i).Queue = True
                        Case Else
                            MsgBox "Invalid " & arry1(j) & " in Profile Section " & Section
                        End Select
                    Next j
                Case Is = "Multiplier"
'if Options > Speed > Times 10 is checked this overrides profile setting
                    If frmMain.mnux10.Checked = False Then
                        Multiplier = CLng(arry(1))
                        If Multiplier < 1 Then Multiplier = 1
                    End If
                Case Is = "ClassSeparation"
'If defined then all Class Sections are ignored
                    ClassSeparation = CLng(arry(1))
                Case Is = "RecallControl"
                    RecallControl = AtoBool(arry(1))
                Case Is = "ButtonControl"
                    ButtonControl = AtoBool(arry(1))
                Case Is = "ButtonEvents"
                    ButtonEvents = AtoBool(arry(1))
                Case Is = "ClassSilenceControl"
                    ClassSilenceControl = AtoBool(arry(1))
                Case Is = "SoundOnAllFinishers"
                    SoundOnAllFinishers = AtoBool(arry(1))
                Case Is = "SkipClassOnRecall"
                    SkipClassOnRecall = AtoBool(arry(1))
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Profile Section " & Section
                End Select
            Case Is = "Class"   'Section Class
                If ClassSeparation > 0 Then GoTo Skip_line     'Ignore Class sections
'Create start time for this class
                Select Case arry(0)
'Class ElapsedTime must only be defined in Profile if Class Separation isnt
                Case Is = "ElapsedTime"
                    Classes(Csidx).ClassStartElapsedTime = arry(1)
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Class Section " & Section
                End Select
            Case Is = "Template"
                Select Case Template
                Case Is = "Recall"
                    ReDim Preserve RecallTemplate(UBound(RecallTemplate) + 1)
                    Select Case arry(0)
                    Case Is = "Event", "/Event"
'Re-insert the [] which have been cleaned off, so LaosRecall will
'Identify the Open & Close
                        RecallTemplate(UBound(RecallTemplate)) = _
                        "[" & CleanLine & "]"
                    Case Else
                        RecallTemplate(UBound(RecallTemplate)) = CleanLine
                    End Select
                Case Is = "Class"   'Create the in memory next line for a class template
'Stop
                    ReDim Preserve ClassTemplate(UBound(ClassTemplate) + 1)
                    Select Case arry(0)
                    Case Is = "Event", "/Event"
'Re-insert the [] which have been cleaned off, so LoadRecall will
'Identify the Open & Close
                        ClassTemplate(UBound(ClassTemplate)) = _
                        "[" & CleanLine & "]"
                    Case Else
                        ClassTemplate(UBound(ClassTemplate)) = CleanLine
                    End Select
                End Select
            Case Is = "Controller"
                Select Case arry(0)
                Case Is = "Name"
                    Controllers(Cidx).Name = arry(1)
                Case Is = "IpAddress"
                    Controllers(Cidx).IpAddress = arry(1)
                Case Is = "On"
                    Controllers(Cidx).On = arry(1)
                Case Is = "Off"
                    Controllers(Cidx).Off = arry(1)
                Case Is = "Connection"
                    Controllers(Cidx).Connection = arry(1)
                Case Is = "Sound"
                    Controllers(Cidx).Sound = arry(1)
                    If FileExists(CommonAppData & "Arundale\RacingSignals\Sounds\" & arry(1)) Then
                        SoundFilePath = CommonAppData & "Arundale\RacingSignals\Sounds\"
                        Call OpenWav(arry(1))
                    Else
MsgBox "Sound File " & arry1(0) & " doesnt exist"
                    End If
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Controller Section " & Section
                End Select
            Case Is = "Signal"
'Check again we've got an index
                If Idx = 0 Then
MsgBox "No index " & arry(0) & " in Profile Section " & Section
                    GoTo Skip_line
                End If
                Select Case arry(0)
                Case Is = "Type"
                    SignalAttributes(Idx).Type = arry(1)
                Case Is = "Name"
                    SignalAttributes(Idx).Name = arry(1)
'Added 27/3/18 to allow removal of [Class=Class 1] 'Must be the name of a flag eg 707
                Case Is = "Class"   'Allocate Class No to a signal
                    SignalAttributes(Idx).Class = arry(1)
                Case Is = "TTL"
                    SignalAttributes(Idx).TTL = arry(1)
'Set TTD as same as TTL (On and Off for same time) - Is a Default
                    SignalAttributes(Idx).TTD = arry(1)
'Set timer interval immediately before it is enabled
'                                frmMain.SignalTimer(Idx).Interval = arry(1)
                Case Is = "TTD"
                    SignalAttributes(Idx).TTD = arry(1)
                Case Is = "Cycles"
'                               Select Case SignalAttributes(Idx).Type
'Type must have been set in .ini before Cycles
'Not used now (I think)                                Case Is = "Recall", "Postpone"
'                                    SignalAttributes(Idx).CyclesRequired = arry(1) / Multiplier
'                                Case Else
                    SignalAttributes(Idx).CyclesRequired = arry(1)
'                                End Select
                Case Is = "UpLink", "DownLink"
                    MyLink.Type = arry(0)
                    MyLink.Flag = arry1(0)
                    If UBound(arry1) > 0 Then
                        MyLink.Raise = AtoBool(arry1(1))
'Create the Links(Next Link Index)
                        Call CreateLink(Idx, MyLink)
                    Else
MsgBox "Flag (" & Idx & "), " & arry(0) & " requires True or False"
                    End If
                Case Is = "Controller"
                    SignalAttributes(Idx).Controller = arry(1)
'Flag attributes
                Case Is = "Flag"
'Put in Image in the Signal attributes
                    If FileExists(SignalImageFilePath & arry1(0) & ".gif") Then
                        Set SignalAttributes(Idx).Image = LoadPicture(SignalImageFilePath & arry1(0) & ".gif")
                    Else
MsgBox "Flag " & arry1(0) & " doesnt exist"
                    End If
#If False Then
                Case Is = "FunctionKey"
'Only Function Keys are valid (at the moment)
                    If Left$(arry(1), 1) = "F" Then
                        i = 111 + Mid$(arry(1), 2)
                    Else
                        i = 0
                    End If
                    If i > 0 And i < 128 Then
'Set Key Function to State.Function that applies to this Key
                        Select Case SignalAttributes(Idx).Name
                        Case Is = "Postpone"
                            Keys(i).Function = 1
                        Case Is = "Recall"
                            Keys(i).Function = 2
                        Case Is = "General Recall"
                            Keys(i).Function = 3
                        Case Is = "Finish"
                            Keys(i).Function = 4
                        Case Else
MsgBox "KeyCode " & arry(1) & " cannot be defined"
                        End Select
                        Keys(i).KeyName = arry(1)
                        Keys(i).Code = i
                        SignalAttributes(Idx).Key = i
                    Else
MsgBox "KeyCode " & arry(1) & " cannot be defined"
                    End If
'not used                    SignalAttributes(Idx).Key = Keys(i).Code
#End If
                Case Is = "Group"
                    SignalAttributes(Idx).group = arry(1)
                    For i = 1 To UBound(GroupDefaults)
                        If GroupDefaults(i).group = arry(1) Then
                            Exit For
                        End If
                    Next i
                    If i <= UBound(GroupDefaults) Then
                        SignalAttributes(Idx).Flag.FixedCol = GroupDefaults(i).FixedCol
                        SignalAttributes(Idx).Flag.FixedRow = GroupDefaults(i).FixedRow
                        SignalAttributes(Idx).Flag.Queue = GroupDefaults(i).Queue
                    End If
                Case Is = "Row"
                    SignalAttributes(Idx).Flag.FixedRow = arry(1)
                        
'Raise on load Testing only, can only do when This Signal is closed, as we do not know the position
                Case Is = "Raised"
 'Initially display the flag for debugging the Position
                    If AtoBool(arry(1)) = True Then
                        Call frmMain.RaiseRequest(Idx)
                    End If
'CommandAttributes
                Case Is = "CommandVisible"
                    frmMain.Commands(Idx).Visible = AtoBool(arry(1))
'CommandFrame not currently used
                Case Is = "CommandFrame"
'                                    Set MyFrame = NametoFrame(arry(1))  'an Object
                    Select Case arry(1)
                    Case Is = "Postponement", "Horn"
                        Set frmMain.Commands(Idx).Container = MyFrame
                        frmMain.Commands(Idx).Top = 0
                        frmMain.Commands(Idx).Left = 0
                        frmMain.Commands(Idx).Width = 1700
'Position in middle of frame at the bottom
                        frmMain.Commands(Idx).Move _
                        (MyFrame.Width _
                        - frmMain.Commands(Idx).Width) / 2 _
                        , MyFrame.Height _
                        - frmMain.Commands(Idx).Height - 100
                        MyFont.Name = "Verdana"
                        MyFont.Size = 14
                        MyFont.Bold = True
                        Set frmMain.Commands(Idx).Font = MyFont
                    Case Else
MsgBox "Command Frame " & arry(1) & " Container doesnt exist"

                    End Select
'frmMain.Commands(Idx).Visible = True
'Stop
                Case Else
MsgBox "Invalid " & arry(0) & " in Profile Section " & Section
                End Select  'of [Signal]
            Case Is = "Event"
                Call EventUpdate(Eidx, CleanLine)
            Case Else
MsgBox "Line Outside section" & vbCrLf & nextline & vbCrLf, vbExclamation, "LoadProfile"
            End Select
        
        Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadProfile"
            GoTo Skip_line
        End Select

Skip_line:
'Call CleanProfileLine(NextLine)
    Loop
    Close #ch
    Kill DecryptedFileName

WriteLog "Decrypted file processed" 'Don't give user a clue that a temp file has been created

'    Call frmEvents.ListEvents
'Check Command Button Signals have been defined
    Call CommandIdx("Postpone")
    Call CommandIdx("Horn Short")
    Call CommandIdx("Recall")
    Call CommandIdx("General Recall")
    Call CommandIdx("Finish")
    RecallSignalIdx = SignalFromName("Recall Class")
    If RecallSignalIdx = 0 Then
MsgBox "Recall Class Signal not defined", vbCritical, "LoadProfile"
    End If

Stop
    If ClassSeparation > 0 Then
        Csidx = NewClass  'set a minimum of one class
        For Idx = 1 To Csidx
            Call LoadClassEvents(Classes(Idx).ClassStartElapsedTime / Multiplier)
        Next Idx
    End If
    If IsEvtsInitialised(Evts) Then
'Silence Class Flags raised at same time as a Class Flag is Lowered
        If ClassSilenceControl Then Call ClassSilence
'Load Recalls for all Classes into evts
        If RecallControl Then Call ClassRecalls
    Else
        MsgBox "No Events have been created", vbCritical, "LoadProfile"
    End If
Stop

'Clear the Splash display (after 3 secs) - Not fully loaded until Splash screen has
'been cleared
    frmMain.ClearFlagsTimer.Enabled = True
    
'    frmMain.cmdEvents.Enabled = True
'    Loading = False
    frmMain.RaceTimer.Enabled = True
WriteLog "RaceTimer Enabled"
'temp stop    frmMain.RaceTimer.Enabled = True
    If frmMain.mnuEvents.Checked = True Then
        Call frmEvents.ListEvents
    End If
Exit Function

LoadProfile_err:
    Select Case Err.Number
    End Select
    WriteLog "LoadProfile Error " & Str(Err.Number) & " " & Err.Description
    MsgBox "LoadProfile Error " & Str(Err.Number) & " " & Err.Description, vbCritical, "LoadProfile"
End Function
    
'Returns "Open","Close","Update","Skip"
'And cleans inbuf (removes comments and whitespace)
Private Function CleanProfileLine(ByRef Inbuf As String) As String
Dim i As Long
Dim j As Long
Dim CleanLine As String
Dim CleanSection As String

'Strip Comments
        i = InStr(1, Inbuf, "'")
        If i > 0 Then
            CleanLine = Left$(Inbuf, i - 1)
        Else
            CleanLine = Inbuf
        End If
'Remove leading & trailing whitespace
        CleanLine = Replace(CleanLine, vbTab, "")
        CleanLine = Trim(CleanLine)
        If CleanLine = "" Then GoTo Skip_line
'Debug.Print CleanLine
        i = InStr(1, CleanLine, "[")
        If (i > 0) Then
'This is Open or Close Section
            j = InStrRev(CleanLine, "]")
            If j < i Then
                MsgBox "Parse error:" & vbCrLf & Inbuf, vbCritical, "LoadProfile"
                GoTo Skip_line   'Skip this line (no closing bracket)
            End If
            CleanSection = Mid$(CleanLine, i + 1, j - i - 1)
            If Len(CleanSection) = 0 Then   'Blank section
                GoTo Skip_line
            End If
'If Cleaned up Section not blank
            Inbuf = CleanSection
            If Mid$(CleanLine, 2, 1) <> "/" Then
'Open section (Sets up Section & SectionIndex to be used by next Input Lines
                CleanProfileLine = "Open"
            Else
                CleanProfileLine = "Close"
            End If
    Else
        Inbuf = CleanLine
        CleanProfileLine = "Update"
    End If
Finish:
Exit Function

Skip_line:
    CleanProfileLine = "Skip"
    GoTo Finish
End Function

'Returns Eidx, Check Eidx ensures it is not already open
Private Function EventOpen(ByVal ElapsedTime As Long) As Long
    EventOpen = FreeEidx(ElapsedTime)
End Function

'Eidx is dealt with like Ch on File Open,Read,Close
'Must be by Ref to Update Eidx in ModMain
Private Function EventClose(ByVal Eidx As Long) As Long
    If Eidx = -9999 Then
MsgBox "Event not open", vbCritical, "EventClose"
        Exit Function
    End If
    EventClose = -9999
End Function

'Only Called while profile is being loaded
'by LoadProfile,LoadRecallEvents,LoadClassEvents,LoadFinishEvents
Private Function EventUpdate(ByVal Eidx As Long, ByVal Inbuf As String)
Dim arry() As String
Dim arry1() As String
Dim Bidx As Long    'OK here because all args passed on same line
Dim Fcidx As Long

'Split the line arry Name=Value1,Value2
    If Eidx = -9999 Then
MsgBox "Event not open", vbCritical, "EventUpdate"
        Exit Function
    End If
    If CleanProfileLine(Inbuf) <> "Update" Then
'Cleans Inbuf
'Stop
        Exit Function
    End If
    arry = Split(Inbuf, "=")
    ReDim arry1(0)
    If UBound(arry) > 0 Then
        arry1 = Split(arry(1), ",")
    End If
        Select Case arry(0)
        Case Is = "Signal"
'get a new index
'If arry(1) = "Class 3" Then Stop
            Sidx = FreeSidx(Eidx, SignalFromName(arry(1)))
            Call PutSignalEvent(Eidx, Sidx)
        Case Is = "Button"
            Bidx = FreeBidx(Eidx, SignalFromName(arry1(0)))
            Call PutButtonEvent(Eidx, Bidx, arry1(1))   'Enabled
        Case Is = "Message"
'Make the event message the first one for this time.
'This Should be the class start
            If Evts(Eidx).Message = "" Then
                Call PutEvent(Eidx, arry(1))
            End If
        Case Is = "Focus"
            Call PutEvent(Eidx, , arry1(0))
        Case Is = "Raised"
'Needs Sidx passing, must have been defined with [Signal=]
            Call PutSignalEvent(Eidx, Sidx, arry(1))
        Case Is = "Silent"
'Needs Sidx passing
            Call PutSignalEvent(Eidx, Sidx, , arry(1))
        Case Is = "Recalls"
            Bidx = FreeBidx(Eidx, frmMain.CommandFromCaption("Recall"))
            Call PutButtonEvent(Eidx, Bidx, arry(1))   'Enabled
            Bidx = FreeBidx(Eidx, frmMain.CommandFromCaption("General Recall"))
            Call PutButtonEvent(Eidx, Bidx, arry(1))   'Enabled
'Must do after Button has been enables - to set the Focus
            If AtoBool(arry(1)) = True Then
                Call PutEvent(Eidx, "Enable Recalls", "Recall")
            Else
                Call PutEvent(Eidx, "Disable Recalls")
            End If
        Case Is = "FunctionCall"
            Select Case arry1(0)
            Case Is = "QueryRecallTimeout", "RecallTimeout", "LoadPostpone" _
            , "UnloadPostpone", "LoadStart"
                Fcidx = FreeFcidx(Eidx, arry1(0))
                Call PutFunctionCallEvent(Eidx, Fcidx, arry(1))   'Name
            Case Else
             MsgBox "Invalid Function Call-" & arry(0), vbCritical, "EventUpdate"
            End Select
        Case Else
 MsgBox "Invalid Event-" & arry(0), vbCritical, "EventUpdate"
        End Select  'of [Signal]

End Function

Private Function LoadRecallEvents(ByVal ElapsedTime As Long)
Dim i As Long
Dim nextline As String
Dim arry() As String
Dim EventOffset As Long
Dim LineType As String
Dim RecallEidx As Long    'Only for the recall
Dim kb As String
    
    RecallEidx = -9999
    For i = 0 To UBound(RecallTemplate)
        nextline = RecallTemplate(i)
        If nextline = "" Then GoTo Skip_line
        arry = Split(nextline, "=")
        Select Case arry(0)
        Case Is = "EventOffset"
            EventOffset = arry(1) / Multiplier
        Case Else
            LineType = CleanProfileLine(nextline)   'NextLine is cleaned
'Helpds debugging
            nextline = Replace(nextline, "<ElapsedTime>", ElapsedTime)
            nextline = Replace(nextline, "<EventOffset>", EventOffset)
            nextline = Replace(nextline, "<ClassName>", EventClassName)
Debug.Print "R>" & nextline
'If Left$(NextLine, 6) = "Signal" Then Stop
            Select Case LineType
            Case Is = "Open"
               If RecallEidx <> -9999 Then
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    Exit Function
                Else
                    RecallEidx = EventOpen(ElapsedTime + EventOffset)
                End If
            Case Is = "Close"
                RecallEidx = EventClose(RecallEidx)
            Case Is = "Update"
'If ElapsedTime + ElapsedOffset = 240 Then Stop
                Call EventUpdate(RecallEidx, nextline)
'frmEvents.ListEvents
'frmEvents.WindowState = vbNormal  'Scale will be 0 in VBE (window is minimized)
'frmEvents.Refresh
'frmEvents.Visible = True
'kb = frmEvents.ScaleHeight
'Stop
            Case Is = "Skip"
            Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadRecallEvents"
            End Select
'            Call ParseProfile(NextLine)
        End Select
Skip_line:
    Next i

'frmEvents.ListEvents
End Function

'Creates one new class and returns the class no created
'Classes(0) exists but is unused
'Ubound(Classes) is last class in use
Private Function NewClass(Optional SignalName As String) As Long
Dim Csidx As Long
Dim Idx As Long
    Csidx = UBound(Classes) + 1
    If Csidx > UBound(Classes) Then
        ReDim Preserve Classes(Csidx)
    End If
    
'The no of starts needs clarifying & simplyfying
    state.StartClass.Last = Csidx
    NoOfStarts = Csidx   'Max allowed
    frmMain.txtNoOfStarts = NoOfStarts
    
    If SignalName = "" Then     'Class No defined in Signal Flag section
        Idx = SignalFromClass(Csidx)
    Else
        Idx = SignalFromName(SignalName) 'Class Flag name defined in Section Class
    End If
    If Idx > 0 Then
        Classes(Csidx).Signal = Idx
        Classes(Csidx).Name = SignalAttributes(Idx).Name
'ClassStartElapsedTime will be overwritten by Profile>Class if Class is defined as a separate section
        Classes(Csidx).ClassStartElapsedTime = (Csidx - 1) * ClassSeparation
        EventClassName = Classes(Csidx).Name
    Else
MsgBox "Class Signal Flag " & Csidx & " is not defined", vbCritical, "LoadProfile"
    End If
    NewClass = Csidx
End Function

Private Function LoadClassEvents(ByVal ElapsedTime As Long)
Dim i As Long
Dim nextline As String
Dim arry() As String
Dim EventOffset As Long
Dim LineType As String
Dim EidxTime As Long    'Only for the Class
Dim kb As String

    EidxTime = -9999   'Assume no event set up (must not be a valid elapsed time)
                        'Because the OpenEidx returns the Elapsed time
    For i = 0 To UBound(ClassTemplate)
        nextline = ClassTemplate(i)
        arry = Split(nextline, "=")
        Select Case arry(0)
        Case Is = "EventOffset"
            EventOffset = arry(1) / Multiplier
        Case Else
            LineType = CleanProfileLine(nextline)   'NextLine is cleaned
'Helpds debugging
            nextline = Replace(nextline, "<ElapsedTime>", ElapsedTime)
            nextline = Replace(nextline, "<EventOffset>", EventOffset)
            nextline = Replace(nextline, "<ClassName>", EventClassName)
Debug.Print "R>" & nextline
'If Left$(NextLine, 6) = "Signal" Then Stop
            Select Case LineType
            Case Is = "Open"
               If EidxTime <> -9999 Then
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    Exit Function
                Else
                    EidxTime = EventOpen((ElapsedTime + EventOffset))
                End If
            Case Is = "Close"
                EidxTime = EventClose(EidxTime)
            Case Is = "Update"
'If ElapsedTime + ElapsedOffset = 240 Then Stop
                Call EventUpdate(EidxTime, nextline)
            Case Is = "Skip"
            Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadClassEvents"
            End Select
'            Call ParseProfile(NextLine)
        End Select
    Next i
'frmEvents.ListEvents
End Function

'Called when LoadProfile is finished
Private Function LoadStartEvents()
Dim Eidx As Long
        
    Eidx = EventOpen(Evts(0).ElapsedTime)
    Evts(Eidx).Message = "Start Sequence"
    Call EventClose(Eidx)
    
End Function

Private Function LoadFinishEvents()
Dim Eidx As Long
            
'    EventClassName = "Finish"
'    Eidx = UBound(Evts)
    
    Eidx = EventOpen(Evts(UBound(Evts)).ElapsedTime + 1)
'This is the very latest you can postpone
'you can change a general recall to postpone

'    Call EventUpdate(Eidx, "Signal=Postpone")
'    Call EventUpdate(Eidx, "Raised=False")
    Call EventUpdate(Eidx, "Button=Postpone,False")
    
    Evts(Eidx).Message = "Finish Enabled"
    Call EventUpdate(Eidx, "Button=Horn Short,True")
'Dont think this should be required
'    Call EventUpdate(Eidx, "Signal=White Fl")
'    Call EventUpdate(Eidx, "Raised=False")
    Call EventUpdate(Eidx, "Focus=Finish")
    Call EventClose(Eidx)
End Function

Public Function CommandExists(Idx As Long) As Boolean
Dim MyCommand As CommandButton
    For Each MyCommand In frmMain.Commands
        If MyCommand.Index = Idx Then
            CommandExists = True
            Exit Function
        End If
    Next MyCommand
End Function

Public Function AtoBool(kb As String) As Boolean
    If kb = "True" Then AtoBool = True
End Function

Public Function CommandIdx(CommandName As String) As Long
Dim kb As String
Dim MyCommand As CommandButton
    
    For Each MyCommand In frmMain.Commands
        If MyCommand.Caption = CommandName Then
            CommandIdx = MyCommand.Index
            Exit Function
        End If
    Next MyCommand
MsgBox "Command Button " & CommandName & " not found", vbExclamation, "CommandIdx"
End Function

Public Function NameFromFullPath(FullPath As String, Optional Delimiter As String, Optional RemoveRollover As Boolean) As String
'Input: Name/Full Path of a file
'Returns: Name of file

    Dim sPath As String
    Dim sList() As String
    Dim sAns As String
    Dim iArrayLen As Integer
    Dim i As Integer
    Dim j As Integer
    Dim kb As String
    
'MsgBox FullPath
    If Delimiter = "" Then Delimiter = "\"
    If Len(FullPath) = 0 Then Exit Function
    sList = Split(FullPath, Delimiter)
    iArrayLen = UBound(sList)
    sAns = IIf(iArrayLen = 0, "", sList(iArrayLen))
'only filename
'MsgBox FullPath
    If sAns = "" And iArrayLen = 0 Then sAns = FullPath
    If RemoveRollover And sAns <> "" Then
        j = InStr(sAns, ".") 'get the first dot
        If j = 0 Then j = Len(sAns) 'no dot so all the string
        i = InStrRev(Left$(sAns, j), "_")
        If j = i + 9 Then 'msu be _yyyymmdd.
            If IsNumeric(Mid$(sAns, i + 1, 8)) Then
                sAns = Replace(sAns, Mid$(sAns, i, 9), "")
            End If
        End If
    End If
    
    NameFromFullPath = sAns

End Function


' Return True if a file exists
Public Function FileExists(FileName As String) As Boolean
    FileExists = False
'MsgBox FileName & ":" & GetAttr(FileName)
    On Error GoTo ErrorHandler
    If NameFromFullPath(FileName) <> "" Then  'directory
'does file exists
        If (GetAttr(FileName) And vbNormal) = vbNormal Then FileExists = True
    End If
ErrorHandler:
    ' if an error occurs, this function returns False
'MsgBox FileName & vbCrLf & FileExists
End Function

Public Function CreateLink(ByRef Idx As Long, Link As defLink)
    With SignalAttributes(Idx)
        If IsLinksInitialised(.Links) = False Then
            ReDim .Links(0)
        Else
            ReDim Preserve .Links(UBound(.Links) + 1)
        End If
        .Links(UBound(.Links)) = Link
    End With
End Function

Public Function IsLinksInitialised(ByRef arr() As defLink) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsLinksInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsEvtsInitialised(ByRef arr() As defEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsEvtsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsSignalsInitialised(ByRef arr() As defSignalEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsSignalsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsButtonsInitialised(ByRef arr() As defButtonEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsButtonsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsFunctionCallsInitialised(ByRef arr() As defFunctionCallEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsFunctionCallsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsKeysInitialised(ByRef arr() As defKey) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsKeysInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsClassesInitialised(ByRef arr() As defClass) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsClassesInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

'Returns the index from the Signal name,
'Only used by LoadProfile so that the .ini file can refer to it by name which makes
'Setting up the initialisation file easier.
'Return 0 if not found
Public Function SignalFromName(ByVal Name As String) As Long
Dim Idx As Long

    For Idx = 1 To UBound(SignalAttributes)
        With SignalAttributes(Idx)
            If .Name = Name Then
                SignalFromName = Idx
                Exit For
            End If
        End With
    Next Idx
End Function

'Replaces SignalFromName (above) when creating Classes(CsIdx).name
Public Function SignalFromClass(ByVal Csidx As Long) As Long
Dim Idx As Long

    For Idx = 1 To UBound(SignalAttributes)
        With SignalAttributes(Idx)
            If .Class = Csidx Then
                SignalFromClass = Idx
                Exit For
            End If
        End With
    Next Idx
End Function

'Return Eidx of first event at this time -1 = not found
Public Function EventToEidx(ByVal ElapsedTime, ByVal Idx As Long) As Long
Dim Eidx As Long

    EventToEidx = -1
    If IsEvtsInitialised(Evts) Then
        For Eidx = 0 To UBound(Evts)
            If Evts(Eidx).ElapsedTime = ElapsedTime And Evts(Eidx).Signal = Idx Then
                EventToEidx = Eidx
                Exit Function
            End If
        Next Eidx
    End If
End Function

'only Called by EventUpdate
Public Function PutEvent(ByVal Eidx As Long, Optional Message As String, Optional FocusName As String)
    If Message <> "" Then
        Evts(Eidx).Message = Evts(Eidx).Message & Message
    End If
    If FocusName <> "" Then
        Evts(Eidx).Focus = frmMain.CommandFromCaption(FocusName)
    End If

End Function

Public Function PutButtonEvent(ByVal Eidx As Long, ByVal Bidx As Long, Optional Enabled As String)
    If Enabled <> "" Then
        Evts(Eidx).Buttons(Bidx).Enabled = Enabled
    End If
End Function

Public Function PutFunctionCallEvent(ByVal Eidx As Long, ByVal Fcidx As Long, Optional Name As String)
    If Name <> "" Then
        Evts(Eidx).FunctionCalls(Fcidx).Name = Name
    End If
End Function

'Signal must have been defined
Public Function PutSignalEvent(ByVal Eidx As Long, ByVal Sidx As Long, Optional Raise As String, Optional Silent As String)
    If Raise <> "" Then
        Evts(Eidx).Signals(Sidx).Raise = Raise
    End If
    If Silent <> "" Then
        Evts(Eidx).Signals(Sidx).Silent = Silent
    End If
End Function

'Returns EidxTime
Public Function FreeEidx(ByVal ElapsedTime As Long) As Long
Dim Eidx As Long
Dim i As Long
Dim j As Long
Dim BlankEvt As defEvt
Dim Idx As Long

    Idx = SignalFromName(EventClassName)
    If Not IsEvtsInitialised(Evts) Then
        ReDim Evts(0)
        Eidx = 0
        Evts(Eidx).Signal = Idx   'only when first created
        Evts(Eidx).Class = SignalAttributes(Idx).Class
    Else
'See if we already have this event time and Class set up, returns -1 if not set up
        Eidx = EventToEidx(ElapsedTime, Idx)
        If Eidx < 0 Then
'Event for this time is not set up is not set up
'Is this a later event than the latest one
            If ElapsedTime > Evts(UBound(Evts)).ElapsedTime Then
                Eidx = UBound(Evts) + 1
                ReDim Preserve Evts(Eidx)
                Evts(Eidx).Signal = Idx   'only when first created
                Evts(Eidx).Class = SignalAttributes(Idx).Class
            Else
'Earlier than latest event, shift events to create a blank event at the required time
'Get the first event that wants shifting up
                For i = 0 To UBound(Evts)
                    If Evts(i).ElapsedTime > ElapsedTime Then Exit For
                Next i
'Now Create a new Blank record on the top
                ReDim Preserve Evts(UBound(Evts) + 1)
'Work Sown the array moving each one up
                For j = UBound(Evts) To i + 1 Step -1
                    Evts(j) = Evts(j - 1)
                Next j
'J is 1 less on exit
                Evts(j) = BlankEvt
                Eidx = j
                Evts(Eidx).Signal = Idx   'only when first created
                Evts(Eidx).Class = SignalAttributes(Idx).Class
            End If
        End If
    End If
    Evts(Eidx).ElapsedTime = ElapsedTime
    Evts(Eidx).Focus = -1   'Default (0=Commands(0))
    FreeEidx = Eidx
'frmEvents.ListEvents
End Function

'returns -1 if Idx is invalid (0 is valid)
Public Function FreeBidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim Bidx As Long

    If Idx < 0 Then
MsgBox "Invalid Button Index in FreeBidx"
        FreeBidx = -1
        Exit Function
    End If
    
    If Not IsButtonsInitialised(Evts(Eidx).Buttons) Then
        ReDim Evts(Eidx).Buttons(0)
        Bidx = 0
        Evts(Eidx).Buttons(Bidx).Button = Idx
    Else
        Bidx = IsBidx(Eidx, Idx)
        If Bidx = 0 Then
            Bidx = UBound(Evts(Eidx).Buttons) + 1
            ReDim Preserve Evts(Eidx).Buttons(Bidx)
            Evts(Eidx).Buttons(Bidx).Button = Idx
        End If
    End If
'    Evts(Eidx).Buttons(Bidx).signal = SignalFromName(EventClassName)
    FreeBidx = Bidx
End Function

'returns -1 if Idx is invalid (0 is valid)
Public Function FreeFcidx(ByVal Eidx As Long, ByVal FcName As String) As Long
Dim Fcidx As Long

    If FcName = "" Then
MsgBox "Invalid FunctionCalls Index in FreeFcidx"
        FreeFcidx = -1
        Exit Function
    End If
    
    If Not IsFunctionCallsInitialised(Evts(Eidx).FunctionCalls) Then
        ReDim Evts(Eidx).FunctionCalls(0)
        Fcidx = 0
        Evts(Eidx).FunctionCalls(Fcidx).Name = FcName
    Else
        Fcidx = IsFcidx(Eidx, FcName)
        If Fcidx = 0 Then
            Fcidx = UBound(Evts(Eidx).FunctionCalls) + 1
            ReDim Preserve Evts(Eidx).FunctionCalls(Fcidx)
            Evts(Eidx).FunctionCalls(Fcidx).Index = Fcidx
        End If
    End If
'    Evts(Eidx).Buttons(Stidx).signal = SignalFromName(EventClassName)
    FreeFcidx = Fcidx
End Function

'Returns Bidx if an Idx has been set up for this Time
Public Function IsBidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).Buttons)
        If Evts(Eidx).Buttons(i).Button = Idx Then
            IsBidx = i
            Exit Function
        End If
    Next i
End Function

'Returns Fcidx if this FunctionCall has been set up for this Time
Public Function IsFcidx(ByVal Eidx As Long, ByVal Name As String) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).FunctionCalls)
        If Evts(Eidx).FunctionCalls(i).Name = Name Then
            IsFcidx = i
            Exit Function
        End If
    Next i
End Function

'Returns Sidx
Public Function FreeSidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim Sidx As Long

    If Idx < 1 Then
MsgBox "Invalid Signal Index in FreeSidx"
        FreeSidx = -1
        Exit Function
    End If
    
    If Not IsSignalsInitialised(Evts(Eidx).Signals) Then
        ReDim Evts(Eidx).Signals(0)
        Sidx = 0
        Evts(Eidx).Signals(Sidx).Signal = Idx
    Else
        Sidx = IsSidx(Eidx, Idx)
        If Sidx = 0 Then
            Sidx = UBound(Evts(Eidx).Signals) + 1
            ReDim Preserve Evts(Eidx).Signals(Sidx)
            Evts(Eidx).Signals(Sidx).Signal = Idx
        End If
    End If
'Debug.Print EventClassName
'Set up the signal index
'    Evts(Eidx).Signals(Sidx).signal = SignalFromName(EventClassName)
'Stop
    FreeSidx = Sidx
End Function

'Returns Sidx if an Idx has been set up for this Time
Public Function IsSidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).Signals)
        If Evts(Eidx).Signals(i).Signal = Idx Then
            IsSidx = i
            Exit Function
        End If
    Next i
End Function

'
Private Function ClassRecalls()
Dim Eidx As Long
Dim Sidx As Long
Dim Csidx As Long
Dim Fcidx As Long
Dim i As Long

'Create start times in Classes
'Must be done in 1 pass because evts will be inserted before the
'current event so Evts & Eidx would change between each pass
    
    For Eidx = 0 To UBound(Evts)
        If IsSignalsInitialised(Evts(Eidx).Signals) Then
            For Sidx = 0 To UBound(Evts(Eidx).Signals)
                If SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).group = "Class" Then
                    For Csidx = 1 To UBound(Classes)
                        If Classes(Csidx).Name = SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).Name Then
                            Exit For
                        End If
                    Next Csidx
                    If Evts(Eidx).Signals(Sidx).Raise = "True" Then
                        Classes(Csidx).Signal = Evts(Eidx).Signals(Sidx).Signal
                        Classes(Csidx).Warning = Evts(Eidx).ElapsedTime
'                    Else
'                        Classes(Csidx).Start = Evts(Eidx).ElapsedTime
                    End If
                End If
            Next Sidx
        End If
        If IsFunctionCallsInitialised(Evts(Eidx).FunctionCalls) Then
            For Fcidx = 0 To UBound(Evts(Eidx).FunctionCalls)
                If Evts(Eidx).FunctionCalls(Fcidx).Name = "LoadStart" Then
                    Classes(Evts(Eidx).Class).start = Evts(Eidx).ElapsedTime
                End If
            Next Fcidx
        End If
    Next Eidx
     
    EventClassName = Classes(1).Name
    Call LoadStartEvents
    For Csidx = 1 To UBound(Classes)
'Set the EventClass name that will be associated with the Signal & button events
        EventClassName = Classes(Csidx).Name
        Call LoadRecallEvents(Classes(Csidx).start)
    Next Csidx
    EventClassName = Classes(UBound(Classes)).Name
    Call LoadFinishEvents
End Function
'SYC if we are raising the next Class flag at the same time as lowering
'the Start Class flag, we must silence the raised flag
'(ie the next class Warning)
Private Function ClassSilence()
Dim Eidx As Long
Dim Sidx As Long
Dim Silence As Boolean
Dim i As Long

    For Eidx = 0 To UBound(Evts)
        Silence = False
        If IsSignalsInitialised(Evts(Eidx).Signals) Then
            For Sidx = 0 To UBound(Evts(Eidx).Signals)
                If SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).group = "Class" Then
                    If Evts(Eidx).Signals(Sidx).Raise = "False" Then
                        Silence = True
                    Else
                        If Silence = True Then
                            Evts(Eidx).Signals(Sidx).Silent = True
                        End If
                    End If
                End If
            Next Sidx
        End If
    Next Eidx
End Function

Public Function aMins(ByVal Seconds As Long) As String
Dim kb As String
    If Seconds < 0 Then kb = "-"
    Seconds = Abs(Seconds)
    
    kb = kb & Format$(Seconds \ 60, "0")
    kb = kb & ":" & Format$(Seconds Mod 60, "00")
    aMins = kb
End Function

'http://www.vbforums.com/showthread.php?267061-*Resolved*-An-empty-UDT-array
Public Function UdtArrayExists() As Boolean
    If SafeArrayGetDim(Evts) > 0 Then
        UdtArrayExists = True
    End If
End Function


Public Function SetState_old(StateType As String, ReqState As Long, Optional FunctionClass As Long)
Dim i As Long
'Stop    'Should no longer be used
    Select Case StateType
    Case Is = "Program"
        state.Program = ReqState
        Select Case state.Program
        Case Is = 0             'No Profile
        Case Is = 1             'Loading Profile
            state.Sequence = 0
'no longer exists            State.FunctionClass = 0
            state.StartClass.Next = 0
            state.StartClass.Previous = 0
            state.EventPause = 0
        Case Is = 2             'Profile Loaded Called by ClearFlagsTimer event
            state.Sequence = 1  'NotStarted
        Case Is = 3             'Start Time Set
'            State.FunctionClass = 1 'Class will be 0 when start time is reset
            state.Sequence = 2  'Postpone
'no longer exists            Keys(Functions(State.Sequence).Keyno).Class = 1
'Stop
            state.StartClass.Previous = 0
            state.StartClass.Next = 1
'Must be done by calling SetState to force update of startTimes display
        Case Is = 4     'Start Sequence Running
'no longer exists            State.FunctionClass = 1 'Must be first class start
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = 1
'Stop
        Case Is = 5     'Start Sequence Finished
        Case Else
            MsgBox "Undefined StateType " & ReqState, , "SetState"
    End Select
    Case Is = "Function"    'Change Function Key
        state.Sequence = ReqState
'        Keys(Functions(State.Function).Keyno).Function = ReqState
        Select Case state.Sequence
        Case Is = 0             'Disabled
        Case Is = 1             'Postpone"
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Next
        Case Is = 2             'Recall
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Previous
        Case Is = 3             'General Recall
''no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Previous
        Case Is = 4             'Finish
        Case Else               'Undefined Function
            MsgBox "Undefined Function " & ReqState, , "SetState"
        End Select
    
    Case Is = "FunctionClass"
'Stop
'no longer exists        State.FunctionClass = ReqState
'no longer exists Keys(Functions(State.Function).Keyno).Class = ReqState
    Case Is = "ClassRestart"
        state.StartClass.Previous = ReqState
        state.StartClass.Next = ReqState
        state.EventPause = -1
    Case Is = "PreviousStartClass"
'Set both Previous and Next at the same time
'Stop
        If state.StartClass.Previous <> ReqState Then
'Start changed
            state.StartClass.Previous = ReqState
'Set NextStart
            Select Case ReqState
            Case Is = 0:    state.StartClass.Next = 1
            Case Is < UBound(Classes): state.StartClass.Next = ReqState + 1
            Case Is = UBound(Classes): state.StartClass.Next = 0
            Case Else
                MsgBox "Undefined NextClassStart", , "SetState"
            End Select
            Call frmMain.DisplayStartTimes
'            Keys(Functions(State.Function).Keyno).Class = State.startclass.Previous
        End If
    Case Is = "NextEventTime"
    Case Is = "KeyState"
'no longer exists        Keys(Functions(State.Function).Keyno).Cancel = CBool(ReqState)
    Case Else
        MsgBox "Undefined StateType", , "SetState"
    End Select
'wont complile    Call frmMain.DisplayState
End Function

#If False Then
Public Function aGetState() As String
Dim kb As String
Dim SignalName As String

    Select Case state.Program
    Case Is = 0: kb = "Loading Forms"
    Case Is = 1: kb = "Loading Profile"
    Case Is = 2: kb = "Profile Loaded"
    Case Is = 3: kb = "Start Time Set"
    Case Is = 4: kb = "Start Sequence Running"
    Case Is = 5: kb = "Start Sequence Finished"
    Case Else: kb = "Undefined"
    End Select
    Select Case state.Function
    Case Is = 0: kb = kb & ",F=Disabled"
    Case Is = 1
        kb = kb & ",F=Postpone"
        If state.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(state.FunctionClass).Name
        End If
    Case Is = 2
        kb = kb & ",F=Recall"
        If state.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(state.FunctionClass).Name
        End If
    Case Is = 3
        kb = kb & ",F=General Recall"
        If state.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(state.FunctionClass).Name
        End If
    Case Is = 4: kb = kb & ",F=Finish"
    Case Else: kb = kb & ",F=Undefined"
    End Select
    
    If state.StartClass.Previous = 0 Then
        SignalName = "None"
    ElseIf UBound(Classes) = 0 Then 'Classes not initialised
        SignalName = "None"
    Else
        SignalName = Classes(state.StartClass.Previous).Name
    End If
    kb = kb & "," & SignalName
    If state.StartClass.Next = 0 Then
        SignalName = "None"
    ElseIf UBound(Classes) = 0 Then 'Classes not initialised
        SignalName = "None"
    Else
        SignalName = Classes(state.StartClass.Next).Name
    End If
    kb = kb & "-" & SignalName
    aGetState = kb
End Function

    Program As Long     '0=No Profile
                        '1=Loading Profile
                        '2=Profile Loaded
                        '3=Start Time Set
                        '4=Start Sequence Running
                        '5=Start Sequence Finished
    FunctionKey As Long '0=Disabled
                        '1=Postpone
                        '2=Recall
                        '3=General Recall
                        '4=Finish
    start As defStart   'NextClass, PreviousClass
#End If

'0=No Profile,1=Loading Profile,2=Profile Loaded
'3=Start Time Set,4=Start Sequence Running,5=Start Sequence Finished
Public Function SetProgramState(ByVal NewState As Long) As Boolean
WriteLog "Program " & state.NextEventTime
'WriteState ("Enter-ProgramState")
'I think we should always allow a reset to state 0
'and do the same with all other state.'s
'First Check permitted state changes
    Select Case state.Program
    Case Is = 0         'No Profile
        Select Case NewState
        Case Is = 1
            SetProgramState = True
        End Select
    Case Is = 1         'Loading Profile
        Select Case NewState
        Case Is = 2         'Spash Timer has finished, Load Completed
            SetProgramState = True
        End Select
    Case Is = 2
        Select Case NewState
        Case Is = 1, 3      '1=Reload Profile
            SetProgramState = True
        End Select
    Case Is = 3
        Select Case NewState
        Case Is = 1, 4       'Allow reload profile
            SetProgramState = True
        End Select
    Case Is = 4
        Select Case NewState
        Case Is = 1, 5       'Allow reload profile
            SetProgramState = True
        End Select
    Case Is = 5
        Select Case NewState
        Case Is = 1, 2       'Allow reload profile
            SetProgramState = True
        End Select
    End Select
    
    If state.Program = NewState Then    'Cannot change state to existing state
        SetProgramState = False
    End If

'Second Set the New state required - any routines called must assume the
'New Program state
    If SetProgramState = True Then
'Set the NewState first so that any subsequent check of the state are correct
        state.Program = NewState
WriteLog vbTab & "Program State now " & aProgramState(NewState)
        
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case NewState
        Case Is = 1
            'Loading or Reloading Profile (can be done from any State
'Reset all states
            frmMain.KeyPreview = True
            state.Sequence = 0
            Call frmMain.DisplaySequence    'syc update display
            state.Recalls = 0
            state.NextEventTime = 0
            state.StartClass.Previous = 0
            state.StartClass.Next = 0
            state.EventPause = 0
            NoOfStarts = 0
            ReDim Keys(0)
            frmMain.mnux10.Enabled = False
            frmMain.txtFirstStartTime.Enabled = False
            frmMain.txtFirstStartTime.BackColor = cbDisabled
            frmMain.txtNoOfStarts = NoOfStarts
            frmMain.txtNoOfStarts.Enabled = False
            frmMain.txtNoOfStarts.BackColor = cbDisabled
            frmMain.Picture1.BackColor = &H80000004
            frmMain.Settings.Visible = True
WriteLog "LoadProfileTimer.Enabled = " & frmMain.LoadProfileTimer.Enabled
            frmMain.LoadProfileTimer.Enabled = True
        Case Is = 2         'Splash Timer has finished, Load Completed
'            GoPreviousClassState (0)    'Previous=0,Next=1
            frmMain.txtFirstStartTime.Enabled = True
            frmMain.txtFirstStartTime.BackColor = cbEnabled
            If ClassSeparation > 0 Then
                frmMain.txtNoOfStarts.Enabled = True
                frmMain.txtNoOfStarts.BackColor = cbEnabled
                frmMain.txtNoOfStarts.SelStart = Len(frmMain.txtNoOfStarts)
                frmMain.txtNoOfStarts.SetFocus
            Else
'Position cursor at RHS (don't because it's empty)
'                frmMain.txtFirstStartTime.SelStart = Len(frmMain.txtFirstStartTime)
                frmMain.txtFirstStartTime.SetFocus
            End If
             Call GoNextClassStarted
        Case Is = 3     '3=Start Time Set
            Call frmMain.StartTimeIsSet

'If we want to change the start time after it has been set & before the start sequence
'has started we need to look carefully at how to reset the states
            
'Once the Start Sequence has been verified - stop any other forms or settings being changed
#If jnasetup = False Then
           frmDaventech.Visible = False
#End If
            frmMain.Settings.Visible = False
            frmMain.KeyPreview = True

'The Sequence is set to 1, before the Sequence has started
            Call SetSequenceState(1)    'Sequence Not Started
'done in set sequence            Call GoResetKeyState             'Display the Applicable Function Keys
        Case Is = 4                     'Program Start Sequence Started
            frmMain.txtFirstStartTime.Enabled = False
            frmMain.txtFirstStartTime.BackColor = cbDisabled
            frmMain.txtNoOfStarts.Enabled = False
            frmMain.txtNoOfStarts.BackColor = cbDisabled
            Call SetSequenceState(2)
        Case Is = 5     '5=Start Sequence Finished appears to be never set !!
        End Select
        
        Call frmMain.DisplayProgram
    Else
        MsgBox "Cannot change " & aProgramState(state.Program) & vbCrLf _
        & "to " & aProgramState(NewState), , "SetProgramState"
    End If
WriteState ("Exit-ProgramState")
End Function

'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function SetSequenceState(ByVal NewState As Long) As Boolean
Dim OldState As Long    'Keep a copy

'Dim DontResetRecallState As Boolean 'Only if start sequence has started
'First Check permitted state changes
'WriteState ("Enter-SequenceState")
WriteLog "Sequence " & state.NextEventTime
    Select Case state.Sequence
    Case Is = 0             'Disabled
        Select Case NewState
        Case Is = 1         'to Not Started
            SetSequenceState = True
        End Select
    Case Is = 1             'Not Started
        Select Case NewState
        Case Is = 2         ' to Postpone
'            DontResetRecallState = True    'This is done when Disabled to NotStarted
            SetSequenceState = True
        End Select
    Case Is = 2             'Postpone
        Select Case NewState
        Case Is = 3         'Recalls
            SetSequenceState = True
        End Select
    Case Is = 3     'Recalls
        Select Case NewState
        Case Is = 2         'to Postpone (Next Class)
            SetSequenceState = True
        Case Is = 4          'to Finish
            SetSequenceState = True
        End Select
    End Select
        
    If state.Sequence = NewState Then    'Cannot change state to existing state
        SetSequenceState = False
    End If
        
'Second The change of state is validated
'Set the New state required - any routines called must assume the New Sequence state
'Keep a Copy of the old state
    If SetSequenceState = True Then
        OldState = state.Sequence
'Set the NewState first so that any subsequent check of the state are correct
        state.Sequence = NewState
        
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case NewState
        Case Is = 1     '1=Sequence not started
 'remove functionkeys           Call GoResetKeyState
        Case Is = 2     '2=Postpone
'Postpone and recalls are mutually exclusive
            If OldState = 3 Then    'Recalls
                Call SetRecallsState(0)  'Calls GoResetKeyState
'The Previous Start is the NoOfStarts set by the user
                If state.StartClass.Previous = NoOfStarts Then
'The events to be removed must be done at the end of DoTimerEvents because all events for the current time must
'have been completed for the program to be in a stable state
'If the Next Start Sequence is running (as it will be with SYC because the Next Start Flag will already be up)
'then this sequence must be stopped
                    SyncEventsToNoOfStarts = True
                End If
            End If
        Case Is = 3     'Recalls
            Call SetRecallsState(1)  'Recall and General Recall
                                    'Calls GoResetKeyState
        Case Is = 4     'Finish
            Call SetRecallsState(0)  'This will Clear Both Keys
                                    'Calls GoResetKeyState
        End Select
'KeyState is always changed
'Note at the start time it must first be set to 0 when postpone disabled
'Then to Recalls
'Display the changes
        Call frmMain.DisplaySequence
        WriteLog vbTab & aSequenceState(NewState)
    Else
        MsgBox "Cannot change " & aSequenceState(state.Sequence) & vbCrLf _
        & "to " & aSequenceState(NewState), , "SetSequenceState"
    End If
WriteState ("Exit-SequenceState")
End Function

'0=None,1=Both,2=Recall,3=General Recall
Public Function SetRecallsState(ByVal NewState As Long) As Boolean
WriteLog "Recalls " & state.NextEventTime
        
    If NewState = state.Recalls Then
Stop    'Why has the state not changed ?
        If NewState = 0 Then
'Occurs when Recalls is set to 0 before StartSequence commences & postpone
'has not been set because the start time is not set because Events clicked
            Exit Function
        End If
    End If
    
    Select Case state.Recalls
    Case Is = 0         'Not in Recalls State
        Select Case NewState
        Case Is = 1     'None to Both
            SetRecallsState = True
        End Select
    Case Is = 1     'Both
        Select Case NewState
        Case Is = 0     'Both to None (Neither Recall Flag has been raised)
            SetRecallsState = True
        Case Is = 2     'Both to Recall
'Remove the Other Recall
'            Keys(KeyNameToKeyNo("General Recall")).State = 0
'            Call SetKeyState(KeyNameToKeyNo("General Recall"), False)
            SetRecallsState = True
        Case Is = 3     'Both to General Recall
'Remove the Other Recall
'            Call SetKeyState(KeyNameToKeyNo("Recall"), False)
'            Keys(KeyNameToKeyNo("Recall")).State = 0
            SetRecallsState = True
        End Select
    Case Is = 2     'Recall
        Select Case NewState
        Case Is = 0 'Recall to None
            SetRecallsState = True
        End Select
    Case Is = 3     'General Recall
        Select Case NewState
        Case Is = 0 'General Recall to None
            SetRecallsState = True
        End Select
    End Select
    
'If the Recalls state changes, the key state will change
    If SetRecallsState = True Then
        Select Case NewState
            Case Is = 0 'All recalls timed out
            Case Is = 3 'Leave Previous start as next
                state.StartClass.Previous = state.StartClass.Previous
        End Select
        
        state.Recalls = NewState
        Call frmMain.DisplayRecalls 'Update the Recall & General Recall Command Button Visibility
        WriteLog vbTab & aRecallsState(NewState)
        
'remove functionkeys        Call GoResetKeyState 'After NewState is set
    Else
        MsgBox "Cannot change " & aRecallsState(state.Recalls) & vbCrLf _
        & "to " & aRecallsState(NewState), , "SetRecallsState"
    End If
WriteState ("Exit-RecallsState")
End Function

'Called whenever a Class is started by Evts
'By ProgramState when Splash is removed (State.ClassStart.Next=0)
'By GeneralRecall
Public Function GoNextClassStarted() As Boolean
Dim Restart As Boolean
WriteLog "NextClassStarted " & state.NextEventTime

    If state.StartClass.Next = state.StartClass.Previous + 1 Then
        GoNextClassStarted = True
    ElseIf state.StartClass.Next = 0 Then
        GoNextClassStarted = True
    End If
        
    If GoNextClassStarted = True Then
        Select Case state.StartClass.Next
        Case Is = 0     'Initial Call
            Call SetPreviousStartClass(0)   'Next Class Start is set to 1
        Case Is > 0
            Call SetPreviousStartClass(state.StartClass.Next)   'Set both Previous and Next
            Call SetSequenceState(3)     'Recalls will also trigger function key changes
        End Select

'Move to SetPreviousClassStart Display the changes
'        Call frmMain.DisplayPreviousNextStartClass
'Keep this time (in case of General Recall) to display time since the false start
        state.GrStartTime = state.NextEventTime
    Else
        MsgBox "Cannot change " & Classes(state.StartClass.Previous).Name & vbCrLf _
        & "to " & Classes(state.StartClass.Next).Name, , "GoPreviousClassState"
    End If
End Function

'Only called By GoLowerGeneralRecall
Public Function GoPreviousClassStarted(ByVal PreviousClassStarted As Long) As Boolean  'Not used for SYC
Dim Restart As Boolean
WriteLog "PreviousClassStarted " & state.NextEventTime

'A class must have started for a General Recall
    If state.StartClass.Previous > 0 Then
'They should be the same when GeneralRecall is lowered
        If state.StartClass.Previous = state.StartClass.Next Then
            If state.StartClass.Next = state.StartClass.Previous Then
                GoPreviousClassStarted = True
            End If
        End If
    End If
    If GoPreviousClassStarted = True Then
        Call SetPreviousStartClass(state.StartClass.Previous - 1) 'Set both Previous and Next
        Call SetSequenceState(2)     'Postpone will also trigger function key changes

'Display the changes
       Call frmMain.DisplayPreviousNextStartClass
    Else
        MsgBox "Cannot change " & Classes(state.StartClass.Previous).Name & vbCrLf _
        & "to " & Classes(state.StartClass.Next).Name, , "GoPreviousClassState"
    End If
End Function

'Called whenever a Class is started by Evts
'By ProgramState when Splash is removed with (0)
'By GeneralRecall
Public Function GoPreviousClassState(ByVal PreviousClassStarted As Long) As Boolean  'Not used for SYC
Dim Restart As Boolean
WriteLog "PreviousClassState " & state.NextEventTime

'First Check permitted state changes
        Select Case PreviousClassStarted
        Case Is = 0
            GoPreviousClassState = True
        Case Is = state.StartClass.Previous
'Restarting Class
'Stop
            Restart = True
            GoPreviousClassState = True
        Case Is = state.StartClass.Next
'Next Class is starting
            GoPreviousClassState = True
        End Select

'        If ReStart = True Then
'Stop
'        End If

'Second Set the New state required - any routines called must assume the
'New Sequence state
    If GoPreviousClassState = True Then
'Set the NewClass first so that any subsequent check of the state are correct
        Call SetPreviousStartClass(PreviousClassStarted)   'Set both Previous and Next
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case PreviousClassStarted
        Case Is = 0
'            frmMain.lblTimeFromPreviousStart.Visible = False
        Case Is > 0
'Now create any other events required for all starts
            Call SetSequenceState(3)     'Recalls will also trigger function key changes
        End Select

'Display the changes
        Call frmMain.DisplayPreviousNextStartClass
    Else
        MsgBox "Cannot change " & Classes(state.StartClass.Previous).Name & vbCrLf _
        & "to " & Classes(PreviousClassStarted).Name, , "GoPreviousClassState"
    End If
    
        
    
#If False Then
    If NewClass = 0 Then    'Resetting the Previous Class started to 0
'Only Reset the Next Class
        state.StartClass.Next = 1
        GoPreviousClassState = True
    Else
        If NewClass = state.StartClass.Previous + 1 Then
            Call frmMain.LoadStart(NewClass)
            Call SetRecallsState(1)      'Both
'                Call TransitionSubRoutine '(SetPreviousClassState(NewClass) on Exit)
            GoPreviousClassState = True
        End If
    End If
    
    If GoPreviousClassState = True Then
        Call frmMain.DisplayPreviousNextStartClass
    End If
    
    If GoPreviousClassState = False Then
        MsgBox "Cannot change " & Classes(state.StartClass.Previous).Name & vbCrLf _
        & "to " & Classes(NewClass).Name, , "GoPreviousClassState"
    End If
#End If
End Function

'Set the Key states acording to the Sequence State
'0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
Public Function GoResetKeyState() As Boolean  'Not used for SYC
Dim KeyNo As Long
Dim NewKeys() As defKey
WriteLog "Key " & state.NextEventTime

    ReDim NewKeys(UBound(Keys))
    Select Case state.Sequence      '0=NotStarted,1=Postpone,2=Recalls,3=Finish
    Case Is = 0     'Disabled
'Exit Function 'SYC dont enable any function keys
'The Postpone has been enabled before the Sequence has started
        NewKeys(1).state = 0
        NewKeys(2).state = 0
    Case Is = 1     'Not started
        NewKeys(1).state = 1
'        NewKeys(1).State = 0    'syc dont use postpone
        NewKeys(2).state = 0
    Case Is = 2     'Postpone
        NewKeys(1).state = 1
'        NewKeys(1).State = 0    'syc dont use postpone
        NewKeys(2).state = 0
                    'State.Recalls should be 0
    Case Is = 3     'Recalls
'Exit Function 'SYC dont enable any function keys
        Select Case state.Recalls '0=None,1=Both,2=Recall,3=General Recall
            Case Is = 0
                NewKeys(1).state = 0
                NewKeys(2).state = 0
            Case Is = 1
                NewKeys(1).state = 2
                NewKeys(2).state = 3
            Case Is = 2
                NewKeys(1).state = 2
                NewKeys(2).state = 0
            Case Is = 3
                NewKeys(1).state = 0
                NewKeys(2).state = 3
        End Select
    Case Is = 4     'Finish
        NewKeys(1).state = 4
        NewKeys(2).state = 0
    End Select
    
    NewKeys(1).Cancel = False
    NewKeys(2).Cancel = False
    
    For KeyNo = 1 To UBound(Keys)
        If Keys(KeyNo).state <> NewKeys(KeyNo).state Then
           Call SetKeyState(KeyNo, NewKeys(KeyNo).state)    'DisplaysKeys
            GoResetKeyState = True
        End If
        If Keys(KeyNo).Cancel <> NewKeys(KeyNo).Cancel Then
           Call SetKeyCancel(KeyNo, NewKeys(KeyNo).Cancel)    'DisplaysKeys
            GoResetKeyState = True
        End If
    Next KeyNo
    
    
    If GoResetKeyState = False Then
        MsgBox "Key State not changed", , "GoResetKeyState"
    End If
    
End Function

Public Function GoToggleKey(ByVal KeyNo)  'Not used for SYC
        Call SetKeyCancel(KeyNo, Not Keys(KeyNo).Cancel)
        Call frmMain.DisplayKeys
End Function

'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function GoRaisePostpone() As Boolean  'Not used for SYC
Dim Idx As Long
WriteLog "RaisePostpone " & state.NextEventTime
    
'If before First Start all classes are Postponed, so dont set Class flag under postpone
    If state.StartClass.Previous > 0 Then
        Idx = SignalFromName("Postpone Class")
        Set SignalAttributes(Idx).Image = SignalAttributes(Classes(state.StartClass.Next).Signal).Image
    End If
        
    Idx = SignalFromName("Postpone")
    Select Case state.Sequence
    Case Is = 1     'Start Sequence not started
        Call frmMain.RaiseRequest(Idx)
        GoRaisePostpone = True
    Case Is = 2     'Start Sequence started
'Reset Class start and (will start pause so start will be 1 min after Postpone is dropped)
        Call frmMain.ClassRestart(state.StartClass.Next)
        Call frmMain.RaiseRequest(Idx)
        state.EventPause = -1
        GoRaisePostpone = True
'        Stop
    End Select
    
    If GoRaisePostpone = False Then
MsgBox "Cannot Raise Postpone " & aProgramState(state.Program), , "GoRaisePostpone"
    End If
End Function

'Only Called from KeyDown
'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function GoLowerPostpone() As Boolean  'Not used for SYC
Dim Idx As Long
WriteLog "LowerPostpone " & state.NextEventTime

    Idx = SignalFromName("Postpone")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case state.Sequence
        Case Is = 1 'Before Start sequence, no action
            Call frmMain.LowerRequest(Idx)
            GoLowerPostpone = True
        Case Is = 2
            Call frmMain.LowerRequest(Idx)
            state.EventPause = 0
            GoLowerPostpone = True
        End Select
        Idx = SignalFromName("Postpone Class")
        If Idx > 0 Then 'May not have a class flag up prior to start
            Set SignalAttributes(Idx).Image = Nothing
        End If
    End If
    If GoLowerPostpone = False Then
MsgBox "Cannot Lower Postpone " & aProgramState(state.Program), , "GoLowerPostpone"
    End If
End Function

'Called when Recall (F5) Clicked
Public Function GoRaiseRecall()
Dim Idx As Long
WriteLog "RaiseRecall " & state.NextEventTime

    Idx = SignalFromName("Recall Class")
    Set SignalAttributes(Idx).Image = SignalAttributes(Classes(state.StartClass.Previous).Signal).Image
    Idx = SignalFromName("Recall")
    Call frmMain.RaiseRequest(Idx)
    Call SetRecallsState(2)
End Function 'Called 30 secs after start

'Called if RecallFunction Manually called or from Evts after 4 mins
Public Function GoLowerRecall() As Boolean '(ByVal Class As Long, Optional NotPreviousClass As Boolean)
Dim Idx As Long
WriteLog "LowerRecall " & state.NextEventTime

    Idx = SignalFromName("Recall")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case state.Recalls
        Case Is = 2
            GoLowerRecall = True
        End Select
    End If
        
    If GoLowerRecall = True Then
        Call frmMain.LowerRequest(Idx)
        state.EventPause = 0
'Restart
    
    Else
MsgBox "Incorrect Recalls State " & aRecallsState(state.Recalls), , "GoLowerRecall"
    End If
End Function

Public Function GoRaiseGeneralRecall() '(ByVal Class As Long)
Dim Idx As Long
WriteLog "RaiseGeneralRecall " & state.NextEventTime

    Idx = SignalFromName("Recall Class")
    Set SignalAttributes(Idx).Image = SignalAttributes(Classes(state.StartClass.Previous).Signal).Image
'    Call frmMain.ClassRestart(State.StartClass.Previous)    'NextClassStart
    Idx = SignalFromName("General Recall")
    Call frmMain.RaiseRequest(Idx)
'syc treat General Recall same as Recall    State.                   = -1
    Call SetRecallsState(3)  'General Recall
'    Call frmMain.DisplayPreviousNextStartClass

End Function

Public Function GoLowerGeneralRecall() As Boolean
Dim Idx As Long
WriteLog "LowerGeneralRecall " & state.NextEventTime


    Idx = SignalFromName("General Recall")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case state.Recalls
        Case Is = 3
            GoLowerGeneralRecall = True
        End Select
    End If
        
    If GoLowerGeneralRecall = True Then
        Call frmMain.LowerRequest(Idx)
        state.EventPause = 0
'Reset the PreviousClassStart from the Recalled class to the one before
'        If State.StartClass.Previous = 1 Then
'            Call SetSequenceState(1)  'Not yet started
'        End If
'syc        Call GoPreviousClassStarted(State.StartClass.Previous - 1)
'syc        frmMain.lblTimeToNextStart.Visible = True
    Else
MsgBox "Incorrect Recalls State " & aRecallsState(state.Recalls), , "GoLowerGeneralRecall"
    End If
End Function

#If False Then  'Template
Public Function GoXXState(ByVal NewState As Long) As Boolean
    Select Case state.XX
    Case Is = 0         'Forms No Profile
        Select Case NewState
        Case Is = 1     'change from 0 to 1 is permitted
            GoXXState = True
        Case Else
        End Select
    Case Else
    End Select
    
    If GoXXState = True Then
        Select Case NewState
        Case Is = 1
            'Set any other asssociated states (eg  sequence or recalls)
        End Select
    Else
        MsgBox "Cannot change " & aXXState(state.XX) & vbCrLf _
        & "to " & aXXState(NewState), , "GoXXState"
    End If
End Function
#End If

'Also sets the Next Class start to Previous + 1
Public Function SetPreviousStartClass(ByVal Class As Long)
Dim NextClass As Long

'Calc Next Start first to check if anything will change
        Select Case Class
        Case Is < UBound(Classes): NextClass = Class + 1
        Case Is = UBound(Classes): NextClass = 0
        End Select

    If state.StartClass.Previous = Class And state.StartClass.Next = NextClass Then
'Invalid Class will case error
MsgBox "Previous/Next Start Class " & Classes(Class).Name & " not changed", , "SetStartClass"
        Exit Function
    Else
'Display the changes
'SYC        Call frmMain.DisplayPreviousNextStartClass
        If state.StartClass.Previous <> Class Then
            state.StartClass.Previous = Class
            WriteLog vbTab & "Previous=" & Classes(Class).Name
        End If
        If state.StartClass.Next <> NextClass Then
            state.StartClass.Next = NextClass
            WriteLog vbTab & "Next=" & Classes(NextClass).Name
        End If
    End If
        Call frmMain.DisplayPreviousNextStartClass  'SYC
End Function

Public Function SetKeyClass_old(ByVal KeyNo As Long, ByVal Class As Long)
Dim i As Long

    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyClass"
        Exit Function
    End If
    
#If False Then 'Wont complile
    If Keys(KeyNo).Class = Class Then
MsgBox "Key [" & Keys(KeyNo).Name & "] not changed", , "SetKeyClass"
        Exit Function
    Else
        Keys(KeyNo).Class = Class
    End If
#End If
End Function

Public Function SetKeyFunctionCall(ByVal KeyNo, ByVal FunctionCall As String)
'None,GoRaisePostpone,GoLowerPostpone,GoRaiseRecall,GoLowerRecall
'GoRaiseGeneralRecall,GoLowerGeneralRecall,GoRaiseFinish

End Function

'0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
Public Function SetKeyState(ByVal KeyNo, ByVal ReqState As Long)

    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyState"
        Exit Function
    End If
    
    If Keys(KeyNo).state <> ReqState Then
        Keys(KeyNo).state = ReqState
        Keys(KeyNo).Cancel = False  'Reset
        Call frmMain.DisplayKeys
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & "=" & aKeyState(Keys(KeyNo).state)
    Else
MsgBox "Key [" & Keys(KeyNo).KeyName & "] not changed", , "SetKeyState"
    End If
End Function

Public Function SetKeyCancel(ByVal KeyNo, ByVal KeyCancel As Boolean)
    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyState"
        Exit Function
    End If
    If Keys(KeyNo).Cancel <> KeyCancel Then
        Keys(KeyNo).Cancel = KeyCancel
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & " Cancel=" & Keys(KeyNo).Cancel
    Else
MsgBox "Key [" & Keys(KeyNo).KeyName & "] not changed", , "SetKeyCancel"
    End If
End Function

Private Function KeyNameToKeyNo(KeyName As String) As Long
Dim KeyNo As Long
    If IsKeysInitialised(Keys) = True Then
        For KeyNo = 1 To UBound(Keys)
            If aKeyState(Keys(KeyNo).state) = KeyName Then
                Exit For
            End If
        Next KeyNo
    End If
End Function

Public Function ClearKeyStates() As Long  'Not used for SYC
Dim KeyNo As Long
    If IsKeysInitialised(Keys) = True Then
        For KeyNo = 1 To UBound(Keys)
            Keys(KeyNo).state = 0
        Next KeyNo
    End If
    Call frmMain.DisplayKeys
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & "=" & aKeyState(Keys(KeyNo).state)
End Function

'Variant to handle Long and Integer
Public Function cbdefault(Idx As Long) As Long
    With frmMain.Commands(Idx)
        If .Enabled = True Then
            cbdefault = cbEnabled       'vbYellow
        Else
            cbdefault = cbDisabled      '&H8000000F
        End If
    End With
End Function

Public Function GetComputerName() As String
Dim sResult As String * 255
    GetComputerNameA sResult, 255
    GetComputerName = Left$(sResult, InStr(sResult, Chr$(0)) - 1)
End Function


Function QuotedString(ByVal kb As String, Optional ByVal Delim As String) As String
Dim Found As Long
If Delim <> "" Then
    Found = InStr(kb, Delim)
Else
    Found = 1
End If
If Found Then
'Replace " with "" if found in field RFC4180
    kb = Replace(kb, """", """""")
    QuotedString = """" & kb & """"
Else
    QuotedString = kb
End If
End Function

